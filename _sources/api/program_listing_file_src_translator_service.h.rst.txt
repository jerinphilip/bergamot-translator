
.. _program_listing_file_src_translator_service.h:

Program Listing for File service.h
==================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_translator_service.h>` (``src/translator/service.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef SRC_BERGAMOT_SERVICE_H_
   #define SRC_BERGAMOT_SERVICE_H_
   
   #include "batch_translator.h"
   #include "batcher.h"
   #include "data/types.h"
   #include "response.h"
   #include "response_builder.h"
   #include "text_processor.h"
   #include "translator/parser.h"
   
   #ifndef WASM_COMPATIBLE_SOURCE
   #include "pcqueue.h"
   #endif
   
   #include <queue>
   #include <vector>
   
   namespace marian {
   namespace bergamot {
   
   // Hack code to construct AlignedMemory* from void*
   inline AlignedMemory hackModel(const void* modelMemory) {
     if(modelMemory != nullptr){
       // Here is a hack to make TranslationModel works
       size_t modelMemorySize = 73837568;   // Hack: model memory size should be changed to actual model size
       AlignedMemory alignedMemory(modelMemorySize);
       memcpy(alignedMemory.begin(), modelMemory, modelMemorySize);
       return alignedMemory;
     } else {
       return AlignedMemory();
     }
   }
   
   inline AlignedMemory hackShortLis(const void* shortlistMemory) {
     if(shortlistMemory!= nullptr) {
       // Hacks to obtain shortlist memory size as this will be checked during construction
       size_t shortlistMemorySize = sizeof(uint64_t) * (6 + *((uint64_t*)shortlistMemory+4))
                                    + sizeof(uint32_t) * *((uint64_t*)shortlistMemory+5);
       // Here is a hack to make TranslationModel works
       AlignedMemory alignedMemory(shortlistMemorySize);
       memcpy(alignedMemory.begin(), shortlistMemory, shortlistMemorySize);
       return alignedMemory;
     }else {
       return AlignedMemory();
     }
   }
   
   class Service {
   
   public:
     explicit Service(Ptr<Options> options, AlignedMemory modelMemory, AlignedMemory shortlistMemory);
   
     explicit Service(Ptr<Options> options) : Service(options, AlignedMemory(),
             AlignedMemory()){}
   
     explicit Service(const std::string &config,
                      const void* modelMemory = nullptr, const void* shortlistMemory = nullptr)
         : Service(parseOptions(config), hackModel(modelMemory), hackShortLis(shortlistMemory)) {}
   
     ~Service();
   
     std::future<Response> translate(std::string &&source);
   
     std::future<Response> translateWithOptions(std::string &&source,
             ResponseOptions options);
   
   private:
     void build_translators(Ptr<Options> options, size_t numTranslators);
     void initialize_blocking_translator();
     void blocking_translate();
   
     void initialize_async_translators();
     void async_translate();
   
     size_t numWorkers_;              // ORDER DEPENDENCY (pcqueue_)
     AlignedMemory modelMemory_;      // ORDER DEPENDENCY (translators_)
     AlignedMemory shortlistMemory_;  // ORDER DEPENDENCY (translators_)
   
     std::vector<BatchTranslator> translators_;  // ORDER DEPENDENCY (modelMemory_, shortlistMemory_)
   
   
     size_t requestId_;
   
     std::vector<Ptr<Vocab const>> vocabs_; // ORDER DEPENDENCY (text_processor_)
   
     TextProcessor text_processor_; // ORDER DEPENDENCY (vocabs_)
   
     Batcher batcher_;
   
     // The following constructs are available providing full capabilities on a non
     // WASM platform, where one does not have to hide threads.
   #ifndef WASM_COMPATIBLE_SOURCE
     PCQueue<Batch> pcqueue_; // ORDER DEPENDENCY (numWorkers_)
     std::vector<std::thread> workers_;
   #endif // WASM_COMPATIBLE_SOURCE
   };
   
   } // namespace bergamot
   } // namespace marian
   
   #endif // SRC_BERGAMOT_SERVICE_H_
