
.. _program_listing_file_src_translator_service.h:

Program Listing for File service.h
==================================

|exhale_lsh| :ref:`Return to documentation for file <file_src_translator_service.h>` (``src/translator/service.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef SRC_BERGAMOT_SERVICE_H_
   #define SRC_BERGAMOT_SERVICE_H_
   
   #include "TranslationRequest.h"
   #include "batch_translator.h"
   #include "batcher.h"
   #include "data/types.h"
   #include "response.h"
   #include "response_builder.h"
   #include "text_processor.h"
   #include "translator/parser.h"
   
   #ifndef WASM_COMPATIBLE_SOURCE
   #include "pcqueue.h"
   #endif
   
   #include <queue>
   #include <vector>
   
   namespace marian {
   namespace bergamot {
   
   class Service {
   
   public:
     explicit Service(Ptr<Options> options, AlignedMemory modelMemory,
                      AlignedMemory shortlistMemory);
   
     explicit Service(Ptr<Options> options)
         : Service(options, AlignedMemory(), AlignedMemory()) {}
   
     explicit Service(const std::string &config,
                      AlignedMemory modelMemory = AlignedMemory(),
                      AlignedMemory shortlistMemory = AlignedMemory())
         : Service(parseOptions(config), std::move(modelMemory),
                   std::move(shortlistMemory)) {}
   
     ~Service();
   
     std::future<Response> translate(std::string &&source);
   
     std::future<Response> translate(std::string &&source,
                                     ResponseOptions options);
   
   
   
     std::vector<Response>
     translateMultiple(std::vector<std::string> &&source,
                       TranslationRequest translationRequest);
   
   private:
     std::future<Response> queueRequest(std::string &&input,
                                        ResponseOptions responseOptions);
   
     void dispatchTranslate();
   
     void build_translators(Ptr<Options> options, size_t numTranslators);
     void initialize_blocking_translator();
     void blocking_translate();
   
     void initialize_async_translators();
     void async_translate();
   
     size_t numWorkers_; // ORDER DEPENDENCY (pcqueue_)
     AlignedMemory modelMemory_; // ORDER DEPENDENCY (translators_)
     AlignedMemory shortlistMemory_; // ORDER DEPENDENCY (translators_)
   
     std::vector<BatchTranslator>
         translators_; // ORDER DEPENDENCY (modelMemory_, shortlistMemory_)
   
   
     size_t requestId_;
   
     std::vector<Ptr<Vocab const>> vocabs_; // ORDER DEPENDENCY (text_processor_)
   
     TextProcessor text_processor_; // ORDER DEPENDENCY (vocabs_)
   
     Batcher batcher_;
   
     // The following constructs are available providing full capabilities on a non
     // WASM platform, where one does not have to hide threads.
   #ifndef WASM_COMPATIBLE_SOURCE
     PCQueue<Batch> pcqueue_; // ORDER DEPENDENCY (numWorkers_)
     std::vector<std::thread> workers_;
   #endif // WASM_COMPATIBLE_SOURCE
   };
   
   } // namespace bergamot
   } // namespace marian
   
   #endif // SRC_BERGAMOT_SERVICE_H_
